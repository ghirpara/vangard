

var log_file;

// Initialize 'static' variables that hold modifier key state
var s_bShiftPressed = false;
var s_bControlPressed = false;
var s_bAltPressed = false;
var s_bMetaPressed = false;
var s_logSourceName = "_DEFAULT_";

function getDefaultLogSourceName() {
    return s_logSourceName;
}

/*********************************************************************/
// void : A function for printing only if debugging
function debug()
{
    // If we are not debugging
    if( !s_bAltPressed ){
        // We are done...
        return;
    }
    
    // Convert the arguments object into an array
    var aArguments = [].slice.call( arguments );
    
    // Print the array
    print( aArguments.join(" ") );
};

/*********************************************************************/
// String : A function for retrieving a translation if one exists
function text( sText )
{
    // If the version of the application supports qsTr()
    if( typeof( qsTr ) != "undefined" ){
        // Return the translated (if any) text
        return qsTr( sText );
    }

    // Return the original text
    return sText;
};

/*********************************************************************/
// void : A function for setting the default options
function setDefaultOptions( oSettings )
{
    // Set the initial state of the compress file checkbox
    oSettings.setBoolValue( "CompressOutput", false );
};

//
// void : A function for updating the keyboard modifier state
//
function updateModifierKeyState() {
    // Get the current modifier key state
    var nModifierState = App.modifierKeyState();
    // Update variables that hold modifier key state
    s_bShiftPressed = (nModifierState & 0x02000000) != 0;
    s_bControlPressed = (nModifierState & 0x04000000) != 0;
    s_bAltPressed = (nModifierState & 0x08000000) != 0;
    s_bMetaPressed = (nModifierState & 0x10000000) != 0;
}

/*********************************************************************/
// void : A function for setting the required options
function setRequiredOptions( oSettings, bShowOptions )
{
    // Set the initial state of the compress file checkbox
    oSettings.setBoolValue( "CompressOutput", false );
    
    // Do not to show the options
    oSettings.setBoolValue( "RunSilent", !bShowOptions );
};


/*********************************************************************/
function init_log(sLogFile, bOverwrite) {

    log_file = DzFile(sLogFile);

    var open_mode = DzFile.Append;

    if (bOverwrite == true) {
        open_mode = DzFile.Truncate;
    }
    
    if (log_file.open (open_mode) == false) {
        App.writeToLog (App.MessageError, "ExtApp:DazCopilotRazor", "Failed to open event logging file: " + sLogFile, true);
        log_file = null;
    } else {
        App.writeToLog (App.MessageNormal, "ExtApp:DazCopilotRazor", "Opened event logging file: " + sLogFile, true);
    }
}


/*********************************************************************/
function close_log() {
    if (log_file != null) {
        log_file.close();
    }
}


/*********************************************************************/
function init_script_utils(log_source_id) {

    s_logSourceName = log_source_id;

    init_log('C:/Temp/razor_events.log', false);

	// If the "Action" global transient is defined, and its the correct type
	if( typeof( Action ) != "undefined" && Action.inherits( "DzScriptAction" ) ){
		// If the current key sequence for the action is not pressed
		if( !App.isKeySequenceDown( Action.shortcut ) ){
			updateModifierKeyState();
		}
	// If the "Action" global transient is not defined
	} else if( typeof( Action ) == "undefined" ) {
		updateModifierKeyState();
	}

    var sVars = JSON.parse(App.scriptArgs[0]);

    log_info("DAZCopilotUtils", 
        {
            'message': "Extracted script Args = " + JSON.stringify(sVars)
        }
    );

    return sVars;

}

/*********************************************************************/
function close_script_utils() {
    close_log();
}

/*********************************************************************/
function log_event(event_type, event_name, event_info) {

    var base_message = {
        'source': s_logSourceName,
        'dtg': Date.now(),
        'event_type': event_type,
        'event_name': event_name
    }

    if (event_info != null && event_info != undefined) {
        keyset = Object.keys(event_info);
        for (var n = 0; n < keyset.length; n++) {
            key = keyset[n];
            value = event_info[key];
            base_message[key] = value;
        }

    }

    log_file.writeLine(JSON.stringify(base_message));

}


/*********************************************************************/
function log_info(event_name, event_info) {
    log_event("INFO", event_name, event_info);
}

function log_warning(event_name, event_info) {
    log_event("WARNING", event_name, event_info);
}

function log_error(event_name, event_info) {
    log_event("ERROR", event_name, event_info);
}

function log_debug(event_name, event_info) {
    log_event("DEBUG", event_name, event_info);
}

/*********************************************************************/
function transferCameraProperties(oTargetCamera, oSourceCamera) {

    var iCountProperties = oSourceCamera.getNumProperties();
    for (var x = 0; x < iCountProperties; x++) {
	oTargetCamera.getProperty(x).setValue(oSourceCamera.getProperty(x).getValue());
    }
}

/*********************************************************************/
function getSkeletonNodes() {

    aSelectedNodes = Scene.getNodeList();
    aSkeletonNodes = [];

    for (var x = 0; x < aSelectedNodes.length; x++) {
	oSelectedNode = aSelectedNodes[x];
	if (oSelectedNode.inherits("DzBone")) {
	    aSkeletonNodes.push (oSelectedNode);
	}
    }
    return aSkeletonNodes;
}


/*********************************************************************/
function transferNodeTransforms(oToNode, oFromNode, bTranslate, bRotate, bScale) {

    if (oFromNode.inherits("DzBone")) {
        from_skeleton = oFromNode.getSkeleton();
    } else {
        from_skeleton = oFromNode
    }

    if (oToNode.inherits("DzBone")) {
        to_skeleton = oToNode.getSkeleton();
    } else {
        to_skeleton = oToNode
    }


    log_info('ObjectTranslation', 
        {
            'from_node': oFromNode.getLabel(),
            'to_node': oToNode.getLabel(),
            'transforms':  {
                'translate': bTranslate,
                'rotate': bRotate,
                'scale': bScale
            }
        }
    );

    if (bTranslate) {

        wsVector = to_skeleton.getWSPos()

        from_skeleton.getXPosControl().setValue (wsVector.x);
        from_skeleton.getYPosControl().setValue (wsVector.y);
        from_skeleton.getZPosControl().setValue (wsVector.z);

    }
    
    if (bRotate) {
        from_skeleton.getXRotControl().setValue (to_skeleton.getXRotControl().getValue());
        from_skeleton.getYRotControl().setValue (to_skeleton.getYRotControl().getValue());
        from_skeleton.getZRotControl().setValue (to_skeleton.getZRotControl().getValue());
    }

    if (bScale) {
        from_skeleton.getXScaleControl().setValue (to_skeleton.getXScaleControl().getValue());
        from_skeleton.getYScaleControl().setValue (to_skeleton.getYScaleControl().getValue());
        from_skeleton.getZScaleControl().setValue (to_skeleton.getZScaleControl().getValue());
    }
}

function getRandomRotationValue(low_range, high_range) {

    output = Math.random() * (high_range - low_range);

    log_info ("DazCopilotUtils",
	      {
		  "function":"getRandomRotationValue",
		  "inputs": [low_range, high_range],
		  "output": output
	      }
	     );
    
    return Number(output);

}

function transformNodeRotate(oFromNode, fValue) {

    if (oFromNode.inherits("DzBone")) {
        from_skeleton = oFromNode.getSkeleton();
    } else {
        from_skeleton = oFromNode
    }

    from_skeleton.getYRotControl().setValue (fValue);
}

function getViewportCamera() {
    //Get perspective view
    var viewPortMgr = MainWindow.getViewportMgr();
    var viewPort = viewPortMgr.getActiveViewport().get3DViewport();
    var camera = viewPort.getCamera();

    return camera;
}

function getNamedCamera(camera_label) {
    return Scene.findCameraByLabel(camera_label);
}

function createPerspectiveCamera(cameraLabelPrefix, cameraName, cameraClass) {
    
    var oNewCamera = null;

    proposed_camera_name = cameraLabelPrefix + " " + cameraName + " " + cameraClass
    test = Scene.findCameraByLabel(proposed_camera_name);
    if (test == null) {

	log_info (sFunctionName,
		  {
		      'camera': {
			  'prefix': cameraLabelPrefix,
			  'name': cameraName,
			  'class': cameraClass,
			  'full_name': proposed_camera_name
		      }
		  }
	     );
	
	
        oNewCamera = DzBasicCamera();
        oNewCamera.setLabel(proposed_camera_name);
        Scene.addNode(oNewCamera);
        log_info('CreatePerspectiveCamera', {'name': proposed_camera_name, 'status': 'success'});
    } else {
        log_info('CreatePerspectiveCamera', {'name': proposed_camera_name, 'status': 'failed', 'message': 'Proposed camera already exists'});
    }

    var camera = getViewportCamera();

    var cameraToCopyCoords = camera.getFocalPoint(); 
    var camPosToCopy = camera.getWSPos();

    oNewCamera.setWSPos(camPosToCopy);
    oNewCamera.aimAt(cameraToCopyCoords);
    
    return oNewCamera;
}

function select_node(label) {
    rv=null;
    Scene.selectAllNodes(false);		
    node   = Scene.findNodeByLabel (label);
    if (node == null) {
	log_warning ("select_node", {"message": "Could not find requested node: " + label});
    } else {
	node.select();
	rv=node;
    }
    return rv;
}

function delete_node(label) {
    rv = select_node(label);
    if (rv != null) {
	valid = Scene.removeNode(rv);
	if (!valid) {
	    log_warning("select_node", {"message": "Failed to remove node: " + label});
	}
    }
}

function get_viewport_camera() {
    // Get the viewport manager
    var oViewportMgr = MainWindow.getViewportMgr();
    
    // Get the active viewport
    var oViewport = oViewportMgr.getActiveViewport();
    
    // Get the 3D viewport
    var o3DViewport = oViewport.get3DViewport();
    
    // Get the active camera for the job
    var oCamera = o3DViewport.getCamera();

    return oCamera;
}

function get_valid_camera_list(oRenderConfig) {

    // Get the list of cameras associated with the scene
    var aCameraList = Scene.getCameraList();
    
    var aCameraListActual = [];
    var sCameraSelectionCriteria = oRenderConfig['cameras'];

    if ((sCameraSelectionCriteria == "all_visible") || (sCameraSelectionCriteria == "pattern")) {
        for (var n = 0; n < aCameraList.length; n++) {
            var oCamera = aCameraList[n];
            var sCameraName = oCamera.getLabel();
            if (sCameraSelectionCriteria == "all_visible") {
                if (oCamera.isVisible()) {
                    aCameraListActual.push(oCamera);
                }
            } else if (sCameraSelectionCriteria == "pattern") {
                var test_pattern = oRenderConfig['camera_pattern'];
                var match_index  = sCameraName.search(test_pattern);
                if (match_index != -1) {
                    aCameraListActual.push(oCamera);
                }
            } 
        }
    } else {
        aCameraListActual.push (get_viewport_camera());
    }

    return aCameraListActual;
}    


function submit_iray_server_render(oIrayConfig, oRenderConfig) {

    // Define the image file extension
    var sExtension = "png";

    App.verbose ("XIRSB: BEGIN iRayServerBatcher process")
    
    // Define the priority of the job; lower value = higher priority
    
    // Define the URI components
    var sProtocol = oIrayConfig['secure_protocol'];
    var sServerAddress = oIrayConfig['iray_host'];
    var sUser = oIrayConfig['iray_user'];
    var sPass = oIrayConfig['iray_password'];
    var iPort = oIrayConfig['iray_port'];

    // Define whether or not to monitor the job
    var bMonitorJob = false;
    
    // Declare working variables
    var oSettings;
    var oSubSettings;

    // Get the render manager
    var oRenderMgr = App.getRenderMgr();
    var oRenderer = oRenderMgr.findRenderer( "DzIrayRenderer" );

    // Get the render options for the job
    var oRenderOptions = oRenderMgr.getRenderOptions();

    // If DzIrayRenderer::setBridgeConfiguration() is available - i.e., 4.21.1.11
    if( typeof( oRenderer.setBridgeConfiguration ) == "function" ) {
        // Create a settings object
        oSettings = new DzSettings();
        
        // Build the configuration settings
        oSettings.setIntValue    ( "Connection", 0 );
        oSettings.setStringValue ( "Server", sServerAddress );
        oSettings.setBoolValue   ( "Secure", sProtocol == "https" );
        oSettings.setIntValue    ( "Port", iPort); //parseInt( sPort ) );
        oSettings.setStringValue ( "Username", sUser);
        oSettings.setStringValue ( "Password", sPass);

        oRenderer.setBridgeConfiguration( oSettings );	
    }

    // Render the current scene
    var sSceneFile = Scene.getFilename();
    var sSceneInfo = DzFileInfo(sSceneFile);
    var sSceneName = sSceneInfo.completeBaseName();

    // Get the list of cameras associated with the scene
    var aCameraList = Scene.getCameraList();
    
    var aCameraListActual = get_valid_camera_list(oRenderConfig);

    var iPriority = oRenderConfig['priority'];
    var frames_per_camera = oRenderConfig['last_frame'] - oRenderConfig['first_frame'];        
    var total_frames = aCameraListActual.length * frames_per_camera;
    var frame_count = 0;

    var sJobNamePattern = oRenderConfig['job_name_pattern'];

    if (sJobNamePattern == undefined) {

        sJobNamePattern  = "%s_%c_%f";

    }
    

    log_info('iray_server_render', {'scenefile': sSceneFile, 'valid_cameras': aCameraListActual});
    
    // Iterate over the cameras in the scene
    for (var n = 0; n < aCameraListActual.length; n++) {

        oCamera = aCameraListActual[n];
        sCameraName = oCamera.getLabel();

        log_info('iray_server_render',
		 {
		     'camera': {
			 'name': sCameraName,
			 'index': n,
			 'total': aCameraListActual.length
		     }
		 }
		)
	
        sJobName = sSceneName + "_" + oCamera.getLabel();

        for (var f = oRenderConfig['first_frame']; f < oRenderConfig['last_frame']; f++) {
	    
            Scene.setFrame(f);
	    
            sJobName = sJobNamePattern.replace('%s', sSceneName);
            sJobName = sJobName.replace('%c', oCamera.getLabel());
            sJobName = sJobName.replace('%f', "" + f);
	
	
            log_info ("iray_server_render",
		      {'camera': sCameraName,
		       'camera_index': n + "/" + aCameraList.length,
		       'frame_index': f + "/" + oRenderConfig['last_frame'],
		       'job_name': sJobName
		      });

            var oResponse = oRenderer.exportRenderToBridgeQueue( 
		sJobName,
		sExtension,
		oCamera,
		oRenderOptions,
		iPriority 
            );

            // Declare working variable
            var sMessage;

            // If we have an error message member
            if( oResponse.hasOwnProperty( "errorMsg" ) ){
		// Get the error message
		sMessage = oResponse[ "errorMsg" ];

		// If we have an error message
		if( !sMessage.isEmpty() ){
		    log_error("iray_server_render",
			      {"message": "nVidia Iray Server Bridge Error",
			       "error": text(sMessage)});
		}
            }
	} // Frame list
    } // Camera List

    log_info('submitted_file', {'filename': sSceneFile});    


    close_script_utils();
}


function getZeroPaddedNumber(input_number, padding_size) {

    var padstr="";
    for (var x = 0; x < padding_size; x++) {
	padstr=padstr+"0";
    }

    paddedNumber = (padstr + String(input_number)).slice (-(padding_size+1))

    return paddedNumber;
}

function getSimpleTextInput(sCurrentText)
{
    
    // Get the current style
    var oStyle = App.getStyle();
    
    // Get the height for buttons
    var nBtnHeight = oStyle.pixelMetric( "DZ_ButtonHeight" );
    
    // Create a basic dialog
    var wDlg = new DzBasicDialog();
    
    // Get the wrapped widget for the dialog
    var oDlgWgt = wDlg.getWidget();
    
    // Set the title of the dialog
    wDlg.caption = "Add scene notes";
    
    // Strip the space for a settings key
    var sKey = wDlg.caption.replace( / /g, "" ) + "Dlg";
    
    // Set an [unique] object name on the wrapped dialog widget;
    // this is used for recording position and size separately
    // from all other [uniquely named] DzBasicDialog instances
    oDlgWgt.objectName = sKey;
    
    // Create a color widget
    var wTextWgt = new DzTextEdit(wDlg);

    if (sCurrentText.trim().length == 0) {
	wTextWgt.text = sCurrentText;
    } else {
	wTextWgt.text = sCurrentText + "\n";
    }

    wTextWgt.readOnly = false;
    wTextWgt.end();
    wTextWgt.ensureCursorVisible();
    
    // Add the widget to the dialog
    wDlg.addWidget( wTextWgt );
    
    // Get the minimum size of the dialog
    var sizeHint = oDlgWgt.minimumSizeHint;
    
    // Set the fixed size of the dialog
    //wDlg.setFixedSize( sizeHint.width, sizeHint.height );

    var rv = "";

    bOut = wDlg.exec();
    App.verbose ("#### Dialog out = " + bOut);
    
    // If the user accepts the dialog
    if( bOut) {
	// Get the color from the widget
	rv = wTextWgt.plainText;
	// If the user rejects the dialog
    }
    
    return rv;
};

//
// void: Render the current scene to a file on disk with the
// subdirectory by date and file name by incrementing sequence number
// OR the file hint if provided.
//
function execLocalRender(oRenderMgr, sOutputBasePath, sFile) {
    // Render the image using the existing render options
    var oRenderer = oRenderMgr.getActiveRenderer();
    // If we did not find a renderer
    if (!oRenderer) {
        // Inform the user
        MessageBox.critical(text("An active renderer could not be found."),
                    text("Resource Error"), text("&OK"));

        // We are done...
        return False;
    }

    var renderFile = sOutputBasePath + "/" + sFile;

    // Set the render options for the icon render
    oRenderOptions = oRenderMgr.getRenderOptions();
    oRenderOptions.isCurrentFrameRender = true;
    oRenderOptions.renderImgToId = DzRenderOptions.DirectToFile;
    oRenderOptions.isAspectConstrained = true;
    oRenderOptions.renderImgFilename = renderFile;

    return oRenderMgr.doRender(oRenderOptions);
}


